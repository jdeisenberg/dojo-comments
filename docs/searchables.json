[{"href": "./index.html", "title": "Home", "contents": "I have fully annotated the parameter and return types for processCell(). You will normally not see ReasonML programmers doing this; they will let ReasonML’s type inference engine do the work for them. So why am I doing this extra work?\nI have, for many years, taught beginning programming courses. Sometimes, I am in the middle of explaining some program that I am live coding, and I stop and tell the class, “I am not explaining how I am writing this to convince you. I’m doing it to convince me.” And that’s why I am fully annotating the types for all my functions: to convince myself that I know exactly what kind of data is coming into and going out of my functions. Your Mileage May Vary.  ", "rendered": "I have fully annotated the parameter and return types for <code>processCell()</code>. You will normally not see ReasonML programmers doing this; they will let ReasonML’s type inference engine do the work for them. So why am I doing this extra work?\nI have, for many years, taught beginning programming courses. Sometimes, I am in the middle of explaining some program that I am live coding, and I stop and tell the class, “I am not explaining how I am writing this to convince you. I’m doing it to convince <em>me</em>.” And that’s why I am fully annotating the types for all my functions: to convince myself that I know exactly what kind of data is coming into and going out of my functions. Your Mileage May Vary.  ", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "I learned a lot in getting this program to work, and I hope you enjoyed going through the process with me.\nThe repository is at https://github.com/jdeisenberg/dojo-comments.", "rendered": "I learned a lot in getting this program to work, and I hope you enjoyed going through the process with me.\nThe repository is at <a href=\"https://github.com/jdeisenberg/dojo-comments\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">https://github.com/jdeisenberg/dojo-comments</a>.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "There you have it, a modest but useful program. Here are the concepts I needed:", "rendered": "There you have it, a modest but useful program. Here are the concepts I needed:", "breadcrumb": "Home"},
{"href": "./index.html#Conclusion", "title": "Conclusion", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let htmlHeader = {js|\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Feedback from European Dojo</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <style type=\"text/css\">\n  body {font-family: helvetica, arial, sans-serif; }\n  dl {\n    margin: 0.5em 0;\n  }\n  dt { color: #666; }\n  dd { margin-bottom: 0.5em; }\n  </style>\n</head>\n<body>\n|js};\n\nlet htmlString = (htmlHeader ++ processRows(headers, contentRows) ++\n  {js|</body>\\n</html>|js});\n\nlet _ = Node.Fs.writeFileAsUtf8Sync(outFile, htmlString);", "rendered": "<pre><code>let htmlHeader = {js|\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Feedback from European Dojo</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <style type=\"text/css\">\n  body {font-family: helvetica, arial, sans-serif; }\n  dl {\n    margin: 0.5em 0;\n  }\n  dt { color: #666; }\n  dd { margin-bottom: 0.5em; }\n  </style>\n</head>\n<body>\n|js};\n\nlet htmlString = (htmlHeader ++ processRows(headers, contentRows) ++\n  {js|</body>\\n</html>|js});\n\nlet _ = Node.Fs.writeFileAsUtf8Sync(outFile, htmlString);</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "To wrap everything up, I sandwiched the processRows() call between strings that provide the HTML header and ending tags, and then used writeFileAsUtf8Sync() to send that to the output file. The {js|...|js} notation lets you have multi-line strings in ReasonML. You also use this notation if you have non-ASCII characters in your strings.", "rendered": "To wrap everything up, I sandwiched the <code>processRows()</code> call between strings that provide the HTML header and ending tags, and then used <code>writeFileAsUtf8Sync()</code> to send that to the output file. The <code>{js|...|js}</code> notation lets you have multi-line strings in ReasonML. You also use this notation if you have non-ASCII characters in your strings.", "breadcrumb": "Home"},
{"href": "./index.html#Finishing-the-Task", "title": "Finishing the Task", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "When processRows() is finished, it will return one very long string that consists of &lt;dl&gt;..&lt;/dl&gt;&lt;hr/&gt;s, one for every row in the CSV file.", "rendered": "When <code>processRows()</code> is finished, it will return one very long string that consists of <code>&lt;dl&gt;..&lt;/dl&gt;&lt;hr/&gt;</code>s, one for every row in the CSV file.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "The right hand side of let helper = createDefnList(headers); calls the createDefnList() function with just the first parameters. The return value, which will be bound to the value helperFcn, is a function that has one argument already supplied, so it needs only one parameter to do its job—and that fulfill’s map()’s requirement for a function that has only one parameter.", "rendered": "The right hand side of <code>let helper = createDefnList(headers);</code> calls the <code>createDefnList()</code> function with just the first parameters. The return value, which will be bound to the value <code>helperFcn</code>, is a function that has one argument already supplied, so it needs only one parameter to do its job—and that fulfill’s <code>map()</code>’s requirement for a function that has only one parameter.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let processRows = (headers: array(string), rows: array(array(string))) : string => {\n  let helperFcn = createDefnList(headers);\n  Arr.map(rows, helperFcn) |.\n    Js.Array.joinWith(\"<hr />\\n\", _);\n};", "rendered": "<pre><code>let processRows = (headers: array(string), rows: array(array(string))) : string => {\n  let helperFcn = createDefnList(headers);\n  Arr.map(rows, helperFcn) |.\n    Js.Array.joinWith(\"<hr />\\n\", _);\n};</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Now I can (finally) process all the rows in the array. My plan is to use Belt.Array.map() to apply createDefnList() to each of the rows in contentRows, which will give me an array of &lt;dl&gt;...&lt;/dl&gt; strings that I can join with &lt;hr/&gt; to visually separate them.  There’s just one problem: the function you give to map() can only have one parameter: the item from the array being processed, and createDefnList() has two parameters: The headers and the contents. There is a solution: currying. All functions in ReasonML are automatically curried—if you call them with fewer parameters than they specify, instead of giving you an error, the function returns a new function with the parameters you supplied “filled in.”  Look at this code:", "rendered": "Now I can (finally) process all the rows in the array. My plan is to use <code>Belt.Array.map()</code> to apply <code>createDefnList()</code> to each of the rows in <code>contentRows</code>, which will give me an array of <code>&lt;dl&gt;...&lt;/dl&gt;</code> strings that I can join with <code>&lt;hr/&gt;</code> to visually separate them.  There’s just one problem: the function you give to <code>map()</code> can only have one parameter: the item from the array being processed, and <code>createDefnList()</code> has two parameters: The headers and the contents. There is a solution: <em>currying</em>. All functions in ReasonML are automatically curried—if you call them with fewer parameters than they specify, instead of giving you an error, the function returns a new function with the parameters you supplied “filled in.”  Look at this code:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Notice that ReasonML has syntactic sugar that lets me write headers[n] instead of having to say Array.get(headers, n). That’s the built-in Array module, not Belt.Array, by the way.", "rendered": "Notice that ReasonML has syntactic sugar that lets me write <code>headers[n]</code> instead of having to say <code>Array.get(headers, n)</code>. That’s the built-in <code>Array</code> module, not <code>Belt.Array</code>, by the way.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "The keyword rec allows me to do recursive call. If the index n is at the end of the array, the function returns the accumulator. Otherwise, it calls the helper function recursively with a new accumulator (the old value plus a new &lt;dt&gt;..&lt;/dt&gt; and &lt;dd&gt;..&lt;/dd&gt;) and the next index value (n + 1).", "rendered": "The keyword <code>rec</code> allows me to do recursive call. If the index <code>n</code> is at the end of the array, the function returns the accumulator. Otherwise, it calls the helper function recursively with a new accumulator (the old value plus a new <code>&lt;dt&gt;..&lt;/dt&gt;</code> and <code>&lt;dd&gt;..&lt;/dd&gt;</code>) and the next index value (<code>n + 1</code>).", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let createDefnList = (headers: array(string), cells: array(string)) : string => {\n\n  let rec helper = (acc: string, n: int) : string => {\n    if (n == Arr.length(headers)) {\n      acc\n    } else {\n      helper(acc ++ \"<dt>\" ++ headers[n] ++ \"</dt>\\n<dd><div>\"\n        ++ processCell(cells[n]) ++ \"</div></dd>\\n\", n + 1) ;\n    }\n  };\n  \n  \"<dl>\" ++ helper(\"\", 0) ++ \"</dl>\\n\\n\";\n};", "rendered": "<pre><code>let createDefnList = (headers: array(string), cells: array(string)) : string => {\n\n  let rec helper = (acc: string, n: int) : string => {\n    if (n == Arr.length(headers)) {\n      acc\n    } else {\n      helper(acc ++ \"<dt>\" ++ headers[n] ++ \"</dt>\\n<dd><div>\"\n        ++ processCell(cells[n]) ++ \"</div></dd>\\n\", n + 1) ;\n    }\n  };\n  \n  \"<dl>\" ++ helper(\"\", 0) ++ \"</dl>\\n\\n\";\n};</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Now I can create a definition list from an array of headers and a row’s worth of cells. I could use Belt.Array.Reduce, but it seemed easier to use a recursive helper function to accumulate a string acc from cell index n:", "rendered": "Now I can create a definition list from an array of headers and a row’s worth of cells. I could use <code>Belt.Array.Reduce</code>, but it seemed easier to use a recursive helper function to accumulate a string <code>acc</code> from cell index <code>n</code>:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let processCell = (s: string) : string => {\n  s |.\n  Js.String.replaceByRe([%re \"/\\\\&/g\"], \"&amp;\", _) |.\n  Js.String.replaceByRe([%re \"/</g\"], \"&lt;\", _) |.\n  Js.String.replaceByRe([%re \"/>/g\"], \"&gt;\", _) |.\n  Js.String.replaceByRe([%re \"/\\\\n/g\"], \"</div><div>\", _);\n};", "rendered": "<pre><code>let processCell = (s: string) : string => {\n  s |.\n  Js.String.replaceByRe([%re \"/\\\\&/g\"], \"&amp;\", _) |.\n  Js.String.replaceByRe([%re \"/</g\"], \"&lt;\", _) |.\n  Js.String.replaceByRe([%re \"/>/g\"], \"&gt;\", _) |.\n  Js.String.replaceByRe([%re \"/\\\\n/g\"], \"</div><div>\", _);\n};</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "As mentioned before, each row will become a definition list, each column as &lt;dt&gt;header&lt;/dt&gt; and the cell data as &lt;dd&gt;&lt;div&gt;content&lt;/div&gt;&lt;/dd&gt;. Why the &lt;div&gt;? That will let me handle cell contents with newlines; I will translate each newline into a &lt;/div&gt;&lt;div&gt;\\n, and they will fit nicely between the beginning and ending tags already in the &lt;dd&gt;. Before I do that, I need to escape entities like &lt;, &gt;, and &amp; within the text. Here’s a function that does that by fast piping a string through a series of global string replacements, courtesy of Js.String.replaceByRe(), where Re stands for regular expression:", "rendered": "As mentioned before, each row will become a definition list, each column as <code>&lt;dt&gt;header&lt;/dt&gt;</code> and the cell data as <code>&lt;dd&gt;&lt;div&gt;content&lt;/div&gt;&lt;/dd&gt;</code>. Why the <code>&lt;div&gt;</code>? That will let me handle cell contents with newlines; I will translate each newline into a <code>&lt;/div&gt;&lt;div&gt;\\n</code>, and they will fit nicely between the beginning and ending tags already in the <code>&lt;dd&gt;</code>. Before I do that, I need to escape entities like <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code> within the text. Here’s a function that does that by fast piping a string through a series of global string replacements, courtesy of <code>Js.String.replaceByRe()</code>, where <code>Re</code> stands for <em>regular expression</em>:", "breadcrumb": "Home"},
{"href": "./index.html#Processing-the-Rows", "title": "Processing the Rows", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "The second line that slices off the contentRows is fine as it is; I want an array of arrays here.", "rendered": "The second line that slices off the <code>contentRows</code> is fine as it is; I <em>want</em> an array of arrays here.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let headers = Arr.getUnsafe(Arr.slice(parseData, ~offset=0, ~len=1), 0);", "rendered": "<pre><code>let headers = Arr.getUnsafe(Arr.slice(parseData, ~offset=0, ~len=1), 0);</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "but I want only a simple array, so I had to pass that result to getUnsafe() to extract the first (and only) sub-array. The fast pipe operator |. sends the value on the left to fill in the _ in the next call. You will often see people using fast pipe instead of nested function calls like this:", "rendered": "but I want only a simple array, so I had to pass that result to <code>getUnsafe()</code> to extract the first (and only) sub-array. The <em>fast pipe</em> operator <code>|.</code> sends the value on the left to fill in the <code>_</code> in the next call. You will often see people using fast pipe instead of nested function calls like this:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "[|\n  [|\"Timestamp\", \"Which dojo did you attend?\", \"Any previous programming experience\"...|]\n|]", "rendered": "<pre><code>[|\n  [|\"Timestamp\", \"Which dojo did you attend?\", \"Any previous programming experience\"...|]\n|]</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Take a closer look at the first line. First, slice() has named parameters. Instead of me having to remember the order of the parameters, and which number comes first—the offset or the length—named parameters let me specify the parameters in any order I please, and the names tell me who’s who and what’s what. The first call splits off the first array in parseData, returning an array of arrays that happens to have only one entry:", "rendered": "Take a closer look at the first line. First, <code>slice()</code> has <em>named parameters</em>. Instead of me having to remember the order of the parameters, and which number comes first—the offset or the length—named parameters let me specify the parameters in any order I please, and the names tell me who’s who and what’s what. The first call splits off the first array in <code>parseData</code>, returning an array of arrays that happens to have only one entry:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let headers = Arr.slice(parseData, ~offset=0, ~len=1) |. Arr.getUnsafe(_,0);\nlet contentRows = Arr.slice(parseData, ~offset=1, ~len=Arr.length(parseData) - 1);", "rendered": "<pre><code>let headers = Arr.slice(parseData, ~offset=0, ~len=1) |. Arr.getUnsafe(_,0);\nlet contentRows = Arr.slice(parseData, ~offset=1, ~len=Arr.length(parseData) - 1);</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "I used Belt.Array.slice() to separate it into two arrays of arrays; the first one containing only the headers, and the second containing the remaining rows:", "rendered": "I used <code>Belt.Array.slice()</code> to separate it into two arrays of arrays; the first one containing only the headers, and the second containing the remaining rows:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "[|\n  [|\"Timestamp\", \"Which dojo did you attend?\", \"Any previous programming experience\"...|],\n  [|\"5/27/2018 19:46:19\", \"Austria, Vienna\", \"Yes\"...|],\n  [|\"5/27/2018 23:08:53\",\"Belgium, Brussels\", \"Yes\"...|]\n|]", "rendered": "<pre><code>[|\n  [|\"Timestamp\", \"Which dojo did you attend?\", \"Any previous programming experience\"...|],\n  [|\"5/27/2018 19:46:19\", \"Austria, Vienna\", \"Yes\"...|],\n  [|\"5/27/2018 23:08:53\",\"Belgium, Brussels\", \"Yes\"...|]\n|]</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "parseData is an array of array of string. For example, the first part of CSV file might parse into something like this (just a segment to give you the idea):", "rendered": "<code>parseData</code> is an array of array of string. For example, the first part of CSV file might parse into something like this (just a segment to give you the idea):", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "```", "rendered": "```", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Note the function call Results.data(...) in the last line. When you created the Results.t data type, ReasonML created getter and setter functions to allow you to read and write fields in the JavaScript object, so Results.data(...) gives back the data field in the result of parse(allLines).", "rendered": "Note the function call <code>Results.data(...)</code> in the last line. When you created the <code>Results.t</code> data type, ReasonML created <em>getter</em> and <em>setter</em> functions to allow you to read and write fields in the JavaScript object, so <code>Results.data(...)</code> gives back the <code>data</code> field in the result of <code>parse(allLines)</code>.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let parseData = Results.data(parse(allLines));", "rendered": "<pre><code>let parseData = Results.data(parse(allLines));</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Now I used this to parse the CSV file and get the data object from the result (I didn’t worry about error or meta; laziness again):", "rendered": "Now I used this to parse the CSV file and get the <code>data</code> object from the result (I didn’t worry about <code>error</code> or <code>meta</code>; laziness again):", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "The [@bs.val] directive says that I am binding to a global value in the modules specified by the [@bs.module] directive. The name I will use for the function is parse, and its signature follows the colon: it has a string parameter and returns a Results.t; this binds to the symbol &quot;parse&quot; in the module.", "rendered": "The <code>[@bs.val]</code> directive says that I am binding to a global value in the modules specified by the <code>[@bs.module]</code> directive. The name I will use for the function is <code>parse</code>, and its signature follows the colon: it has a <code>string</code> parameter and returns a <code>Results.t</code>; this binds to the symbol <code>&quot;parse&quot;</code> in the module.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "[@bs.val] [@bs.module \"papaparse\"] external parse :\n  (string) => Results.t = \"parse\";", "rendered": "<pre><code>[@bs.val] [@bs.module \"papaparse\"] external parse :\n  (string) => Results.t = \"parse\";</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "The parse() function in Papa Parse takes one required parameter: the string to be parsed, and an optional configuration object. It turns out that the defaults for Papa Parse are exactly what I needed, so I did not have to create a new data type for the configuration object. Instead, I wrote this:", "rendered": "The <code>parse()</code> function in Papa Parse takes one required parameter: the string to be parsed, and an optional configuration object. It turns out that the defaults for Papa Parse are exactly what I needed, so I did not have to create a new data type for the configuration object. Instead, I wrote this:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "...and look! I am using types containing other types, as Results.t has a field of type array(Error.t) and another of type Meta.t.", "rendered": "...and look! I am using types containing other types, as <code>Results.t</code> has a field of type <code>array(Error.t)</code> and another of type <code>Meta.t</code>.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "module Meta = {\n  [@bs.deriving abstract] type t = {\n    delimiter: string,\n    linebreak: string,\n    aborted: bool,\n    fields: array(string),\n    truncated: bool\n  }\n};\n\n\nmodule Results = {\n [@bs.deriving abstract] type t = {\n      data: array(array(string)),\n      error: array(Error.t),\n      meta: Meta.t\n  };\n};", "rendered": "<pre><code>module Meta = {\n  [@bs.deriving abstract] type t = {\n    delimiter: string,\n    linebreak: string,\n    aborted: bool,\n    fields: array(string),\n    truncated: bool\n  }\n};\n\n\nmodule Results = {\n [@bs.deriving abstract] type t = {\n      data: array(array(string)),\n      error: array(Error.t),\n      meta: Meta.t\n  };\n};</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "First, the convention for the type name is t. I could have called it errorType, but then every time I wanted to access a field I would have to type Error.errorType..... This way, I refer to Error.t..., which you can mentally read as error type. Second, this object has a field named type, which happens to be a reserved word in ReasonML. To get around this problem, I call the field type_, and the [@bs.as &quot;type&quot;] directive tells ReasonML to compile that field to use the name type when it emits JavaScript. Here are the other two objects that Papa Parse gives you:", "rendered": "First, the convention for the type name is <code>t</code>. I could have called it <code>errorType</code>, but then every time I wanted to access a field I would have to type <code>Error.errorType....</code>. This way, I refer to <code>Error.t...</code>, which you can mentally read as <code>error type</code>. Second, this object has a field named <code>type</code>, which happens to be a reserved word in ReasonML. To get around this problem, I call the field <code>type_</code>, and the <code>[@bs.as &quot;type&quot;]</code> directive tells ReasonML to compile that field to use the name <code>type</code> when it emits JavaScript. Here are the other two objects that Papa Parse gives you:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "module Error = {\n   [@bs.deriving abstract] type t = {\n    [@bs.as \"type\"]  type_: string,\n    code: string,\n    message: string,\n    row: int\n  }\n};", "rendered": "<pre><code>module Error = {\n   [@bs.deriving abstract] type t = {\n    [@bs.as \"type\"]  type_: string,\n    code: string,\n    message: string,\n    row: int\n  }\n};</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "and here it is in ReasonML:", "rendered": "and here it is in ReasonML:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "{\n    type: \"\",     // A generalization of the error\n    code: \"\",     // Standardized error code\n    message: \"\",  // Human-readable details\n    row: 0,       // Row index of parsed data where error is\n    \n}", "rendered": "<pre><code>{\n    type: \"\",     // A generalization of the error\n    code: \"\",     // Standardized error code\n    message: \"\",  // Human-readable details\n    row: 0,       // Row index of parsed data where error is\n    \n}</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "When you parse a CSV string with Papa Parse, you get back an object that contains an array of array of strings, an error object, and a meta-information object. Here is the error object in JavaScript:", "rendered": "When you parse a CSV string with Papa Parse, you get back an object that contains an array of array of strings, an error object, and a meta-information object. Here is the error object in JavaScript:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "It is current practice to put each of these data types in a separate module; this helps avoid name collisions among field names.", "rendered": "It is current practice to put each of these data types in a separate <a href=\"https://reasonml.github.io/docs/en/module.html\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">module</a>; this helps avoid name collisions among field names.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Papa Parse can parse a string that is in CSV format, and it will return a parse results object. Using this required me to write an interface between ReasonML and JavaScript. My first task was to represent the results object(s) in ReasonML. ReasonML has records, which look a lot like JavaScript objects, but aren’t. Instead, you have to create data types that correspond to JavaScript objects, as described in the documentation.", "rendered": "Papa Parse can <a href=\"https://www.papaparse.com/docs#strings\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">parse a string that is in CSV format</a>, and it will return a <a href=\"https://www.papaparse.com/docs#results\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">parse results object</a>. Using this required me to write an interface between ReasonML and JavaScript. My first task was to represent the results object(s) in ReasonML. ReasonML has records, which look a lot like JavaScript objects, but aren’t. Instead, you have to create data types that correspond to JavaScript objects, as described <a href=\"https://bucklescript.github.io/docs/en/object.html#record-mode\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">in the documentation</a>.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "npm install --save papaparse", "rendered": "<pre><code>npm install --save papaparse</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "At this point, I could have written functions to parse CSV, but this is not a well-behaved CSV file; there are newlines and quote marks and commas within the cells. Writing code to handle these cases correctly would have been a nightmare. I decided to avoid the nightmare and the needless duplication of effort, as there are plenty of excellent CSV parsing libraries out there for Node. The one I decided to use was Papa Parse, which I installed with:", "rendered": "At this point, I <em>could</em> have written functions to parse CSV, but this is not a well-behaved CSV file; there are newlines and quote marks and commas within the cells. Writing code to handle these cases correctly would have been a nightmare. I decided to avoid the nightmare and the needless duplication of effort, as there are plenty of excellent CSV parsing libraries out there for Node. The one I decided to use was <a href=\"https://www.papaparse.com/\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">Papa Parse</a>, which I installed with:", "breadcrumb": "Home"},
{"href": "./index.html#Parsing-the-CSV", "title": "Parsing the CSV", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let allLines = Node.Fs.readFileAsUtf8Sync(inFile);", "rendered": "<pre><code>let allLines = Node.Fs.readFileAsUtf8Sync(inFile);</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "ReasonML also has an interface to Node’s file system. I was able to find the readFileAsUtf8Sync() function, which reads the entire file in as a single string. This would not be a good thing to use if I had an enormous, multi-gigabyte CSV file, but for a file the size that I was dealing with, it will do. It’s a synchronous call, so I don’t have to deal with callbacks. When the program finishes, I’ll use the corresponding writeFileAsUtf8Sync() to do my output.", "rendered": "ReasonML also has an <a href=\"https://bucklescript.github.io/bucklescript/api/Node.Fs.html\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">interface to Node’s file system</a>. I was able to find the <code>readFileAsUtf8Sync()</code> function, which reads the entire file in as a single string. This would not be a good thing to use if I had an enormous, multi-gigabyte CSV file, but for a file the size that I was dealing with, it will do. It’s a synchronous call, so I don’t have to deal with callbacks. When the program finishes, I’ll use the corresponding <code>writeFileAsUtf8Sync()</code> to do my output.", "breadcrumb": "Home"},
{"href": "./index.html#Reading-the-Input-File", "title": "Reading the Input File", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "This is where (not for the first time during this program) I got lazy. Belt.Array.get() returns option type, and I really didn’t want to deal with that, so I went with getUnsafe(), which means that if you don’t provide enough arguments to the program, it will crash.", "rendered": "This is where (not for the first time during this program) I got lazy. <code>Belt.Array.get()</code> returns <code>option</code> type, and I really didn’t want to deal with that, so I went with <code>getUnsafe()</code>, which means that if you don’t provide enough arguments to the program, it will crash.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "let args = Node.Process.argv;\nlet outFile = Arr.getUnsafe(args, Arr.length(args) - 1);\nlet inFile = Arr.getUnsafe(args, Arr.length(args) - 2);", "rendered": "<pre><code>let args = Node.Process.argv;\nlet outFile = Arr.getUnsafe(args, Arr.length(args) - 1);\nlet inFile = Arr.getUnsafe(args, Arr.length(args) - 2);</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "and later on in the code:", "rendered": "and later on in the code:", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "module Arr = Belt.Array;", "rendered": "<pre><code>module Arr = Belt.Array;</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "To read command line arguments, you need access to Node’s process global. ReasonML provides an interface to process via BuckleScript. The argv variable gives me an array of command line arguments. For this program, the last element in the array is the output file name, and the next to last is the input file name. Current best practice in ReasonML is to use the Belt.Array module to manipulate arrays. I suspected I would be doing a lot of calls to functions from that module, and I didn’t want to type Belt.Array all the time, so I used a module alias at the top of my code:", "rendered": "To read command line arguments, you need access to Node’s <code>process</code> global. ReasonML provides an <a href=\"https://bucklescript.github.io/bucklescript/api/Node_process.html\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">interface to <code>process</code></a> via BuckleScript. The <code>argv</code> variable gives me an array of command line arguments. For this program, the last element in the array is the output file name, and the next to last is the input file name. Current best practice in ReasonML is to use the <code>Belt.Array</code> module to manipulate arrays. I suspected I would be doing a lot of calls to functions from that module, and I didn’t want to type <code>Belt.Array</code> all the time, so I used a module alias at the top of my code:", "breadcrumb": "Home"},
{"href": "./index.html#Reading-Command-Line-Arguments", "title": "Reading Command Line Arguments", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "code block", "contents": "node src/DojoComments.bs.js inputfile.csv outputfile.html", "rendered": "<pre><code>node src/DojoComments.bs.js inputfile.csv outputfile.html</code></pre>", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Here’s my plan for the program, which I run from the command line as follows:", "rendered": "Here’s my plan for the program, which I run from the command line as follows:", "breadcrumb": "Home"},
{"href": "./index.html#The-Big-Picture", "title": "The Big Picture", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "The problem is that you have to scroll horizontally to read the spreadsheet, making it difficult to get a good picture of the data. I decided to export the spreadsheet as CSV, then write a program in ReasonML to convert the CSV to a somewhat more readable HTML form. You can see the repository at https://github.com/jdeisenberg/dojo-comments. I learned a lot of things writing this, and I’ll share them with you here.", "rendered": "The problem is that you have to scroll horizontally to read the spreadsheet, making it difficult to get a good picture of the data. I decided to <a href=\"feedback.csv\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">export the spreadsheet as CSV</a>, then write a program in ReasonML to convert the CSV to a <a href=\"europe_dojo_feedback.html\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">somewhat more readable HTML form</a>. You can see the repository at <a href=\"https://github.com/jdeisenberg/dojo-comments\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">https://github.com/jdeisenberg/dojo-comments</a>. I learned a lot of things writing this, and I’ll share them with you here.", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "screenshot showing spreadsheet with horizontal scrolling", "rendered": "<img src='google_doc_screenshot.png' alt='screenshot showing spreadsheet with horizontal scrolling' />", "breadcrumb": "Home"},
{"href": "./index.html", "title": "Home", "contents": "Recently, @bsansouci organized a ReasonML dojo that was held simultaneously in several locations in Europe. He provided a feedback form for attendees and put the results in a Google document, which looks like this:", "rendered": "Recently, <a href=\"https://github.com/bsansouci\" target=\"_blank\" rel=\"noopener nofollow\" title=\"\" class=\"external-link\">@bsansouci</a> organized a ReasonML dojo that was held simultaneously in several locations in Europe. He provided a feedback form for attendees and put the results in a Google document, which looks like this:", "breadcrumb": "Home"},
{"href": "./index.html#Converting-CSV-to-HTML", "title": "Converting CSV to HTML", "contents": "", "rendered": "", "breadcrumb": "Home"},
{"href": "./api/DojoComments.html#value-htmlString", "title": "htmlString", "contents": "htmlString string", "rendered": "<h4 class='item'>let htmlString: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-htmlHeader", "title": "htmlHeader", "contents": "htmlHeader string", "rendered": "<h4 class='item'>let htmlHeader: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-contentRows", "title": "contentRows", "contents": "contentRows array array string", "rendered": "<h4 class='item'>let contentRows: array(array(string))</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-headers", "title": "headers", "contents": "headers array string", "rendered": "<h4 class='item'>let headers: array(string)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-parseData", "title": "parseData", "contents": "parseData array array string", "rendered": "<h4 class='item'>let parseData: array(array(string))</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-allLines", "title": "allLines", "contents": "allLines string", "rendered": "<h4 class='item'>let allLines: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-inFile", "title": "inFile", "contents": "inFile string", "rendered": "<h4 class='item'>let inFile: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-outFile", "title": "outFile", "contents": "outFile string", "rendered": "<h4 class='item'>let outFile: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-args", "title": "args", "contents": "args array string", "rendered": "<h4 class='item'>let args: array(string)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-processRows", "title": "processRows", "contents": "processRows array string array array string string  ", "rendered": "<h4 class='item'>let processRows: (\n  array(string),\n  array(array(string))\n) => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-createDefnList", "title": "createDefnList", "contents": "createDefnList array string array string string  ", "rendered": "<h4 class='item'>let createDefnList: (array(string), array(string)) => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-processCell", "title": "processCell", "contents": "processCell string string ", "rendered": "<h4 class='item'>let processCell: string => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-parse", "title": "parse", "contents": "parse string Results t ", "rendered": "<h4 class='item'>let parse: string => <a href=\"./api/DojoComments.html#module-Results\">Results</a>.<a href=\"./api/DojoComments.html#type-Results.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.meta", "title": "Results.meta", "contents": "meta t Meta t ", "rendered": "<h4 class='item'>let meta: <a href=\"./api/DojoComments.html#type-Results.t\">t</a> => <a href=\"./api/DojoComments.html#module-Meta\">Meta</a>.<a href=\"./api/DojoComments.html#type-Meta.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.error", "title": "Results.error", "contents": "error t array Error t ", "rendered": "<h4 class='item'>let error: <a href=\"./api/DojoComments.html#type-Results.t\">t</a> => array(<a href=\"./api/DojoComments.html#module-Error\">Error</a>.<a href=\"./api/DojoComments.html#type-Error.t\">t</a>)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.data", "title": "Results.data", "contents": "data t array array string ", "rendered": "<h4 class='item'>let data: <a href=\"./api/DojoComments.html#type-Results.t\">t</a> => array(array(string))</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.t", "title": "Results.t", "contents": "t array array string array Error t Meta t t data error meta", "rendered": "<h4 class='item'>let t: (\n  ~data: array(array(string)),\n  ~error: array(<a href=\"./api/DojoComments.html#module-Error\">Error</a>.<a href=\"./api/DojoComments.html#type-Error.t\">t</a>),\n  ~meta: <a href=\"./api/DojoComments.html#module-Meta\">Meta</a>.<a href=\"./api/DojoComments.html#type-Meta.t\">t</a>\n) => <a href=\"./api/DojoComments.html#type-Results.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#type-Results.t", "title": "Results.t", "contents": "t ", "rendered": "<h4 class='item'>type t</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Results", "title": "Results", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Results", "title": "Results", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Results", "title": "Results", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.truncated", "title": "Meta.truncated", "contents": "truncated t bool ", "rendered": "<h4 class='item'>let truncated: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => bool</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.fields", "title": "Meta.fields", "contents": "fields t array string ", "rendered": "<h4 class='item'>let fields: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => array(string)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.aborted", "title": "Meta.aborted", "contents": "aborted t bool ", "rendered": "<h4 class='item'>let aborted: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => bool</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.linebreak", "title": "Meta.linebreak", "contents": "linebreak t string ", "rendered": "<h4 class='item'>let linebreak: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.delimiter", "title": "Meta.delimiter", "contents": "delimiter t string ", "rendered": "<h4 class='item'>let delimiter: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.t", "title": "Meta.t", "contents": "t string string bool array string bool t delimiter linebreak aborted fields truncated", "rendered": "<h4 class='item'>let t: (\n  ~delimiter: string,\n  ~linebreak: string,\n  ~aborted: bool,\n  ~fields: array(string),\n  ~truncated: bool\n) => <a href=\"./api/DojoComments.html#type-Meta.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#type-Meta.t", "title": "Meta.t", "contents": "t ", "rendered": "<h4 class='item'>type t</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Meta", "title": "Meta", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Meta", "title": "Meta", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Meta", "title": "Meta", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.row", "title": "Error.row", "contents": "row t int ", "rendered": "<h4 class='item'>let row: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => int</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.message", "title": "Error.message", "contents": "message t string ", "rendered": "<h4 class='item'>let message: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.code", "title": "Error.code", "contents": "code t string ", "rendered": "<h4 class='item'>let code: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.type_", "title": "Error.type_", "contents": "type_ t string ", "rendered": "<h4 class='item'>let type_: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.t", "title": "Error.t", "contents": "t string string string int t type_ code message row", "rendered": "<h4 class='item'>let t: (\n  ~type_: string,\n  ~code: string,\n  ~message: string,\n  ~row: int\n) => <a href=\"./api/DojoComments.html#type-Error.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#type-Error.t", "title": "Error.t", "contents": "t ", "rendered": "<h4 class='item'>type t</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Error", "title": "Error", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Error", "title": "Error", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Error", "title": "Error", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html", "title": "DojoComments", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html", "title": "DojoComments", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#DojoComments", "title": "DojoComments", "contents": "", "rendered": "", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-htmlString", "title": "htmlString", "contents": "htmlString string", "rendered": "<h4 class='item'>let htmlString: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-htmlHeader", "title": "htmlHeader", "contents": "htmlHeader string", "rendered": "<h4 class='item'>let htmlHeader: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-contentRows", "title": "contentRows", "contents": "contentRows array array string", "rendered": "<h4 class='item'>let contentRows: array(array(string))</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-headers", "title": "headers", "contents": "headers array string", "rendered": "<h4 class='item'>let headers: array(string)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-parseData", "title": "parseData", "contents": "parseData array array string", "rendered": "<h4 class='item'>let parseData: array(array(string))</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-allLines", "title": "allLines", "contents": "allLines string", "rendered": "<h4 class='item'>let allLines: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-inFile", "title": "inFile", "contents": "inFile string", "rendered": "<h4 class='item'>let inFile: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-outFile", "title": "outFile", "contents": "outFile string", "rendered": "<h4 class='item'>let outFile: string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-args", "title": "args", "contents": "args array string", "rendered": "<h4 class='item'>let args: array(string)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-processRows", "title": "processRows", "contents": "processRows array string array array string string  ", "rendered": "<h4 class='item'>let processRows: (\n  array(string),\n  array(array(string))\n) => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-createDefnList", "title": "createDefnList", "contents": "createDefnList array string array string string  ", "rendered": "<h4 class='item'>let createDefnList: (array(string), array(string)) => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-processCell", "title": "processCell", "contents": "processCell string string ", "rendered": "<h4 class='item'>let processCell: string => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-parse", "title": "parse", "contents": "parse string Results t ", "rendered": "<h4 class='item'>let parse: string => <a href=\"./api/DojoComments.html#module-Results\">Results</a>.<a href=\"./api/DojoComments.html#type-Results.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.meta", "title": "Results.meta", "contents": "meta t Meta t ", "rendered": "<h4 class='item'>let meta: <a href=\"./api/DojoComments.html#type-Results.t\">t</a> => <a href=\"./api/DojoComments.html#module-Meta\">Meta</a>.<a href=\"./api/DojoComments.html#type-Meta.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.error", "title": "Results.error", "contents": "error t array Error t ", "rendered": "<h4 class='item'>let error: <a href=\"./api/DojoComments.html#type-Results.t\">t</a> => array(<a href=\"./api/DojoComments.html#module-Error\">Error</a>.<a href=\"./api/DojoComments.html#type-Error.t\">t</a>)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.data", "title": "Results.data", "contents": "data t array array string ", "rendered": "<h4 class='item'>let data: <a href=\"./api/DojoComments.html#type-Results.t\">t</a> => array(array(string))</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Results.t", "title": "Results.t", "contents": "t array array string array Error t Meta t t data error meta", "rendered": "<h4 class='item'>let t: (\n  ~data: array(array(string)),\n  ~error: array(<a href=\"./api/DojoComments.html#module-Error\">Error</a>.<a href=\"./api/DojoComments.html#type-Error.t\">t</a>),\n  ~meta: <a href=\"./api/DojoComments.html#module-Meta\">Meta</a>.<a href=\"./api/DojoComments.html#type-Meta.t\">t</a>\n) => <a href=\"./api/DojoComments.html#type-Results.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#type-Results.t", "title": "Results.t", "contents": "t ", "rendered": "<h4 class='item'>type t</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Results", "title": "Results", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Results", "title": "Results", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Results", "title": "Results", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.truncated", "title": "Meta.truncated", "contents": "truncated t bool ", "rendered": "<h4 class='item'>let truncated: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => bool</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.fields", "title": "Meta.fields", "contents": "fields t array string ", "rendered": "<h4 class='item'>let fields: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => array(string)</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.aborted", "title": "Meta.aborted", "contents": "aborted t bool ", "rendered": "<h4 class='item'>let aborted: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => bool</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.linebreak", "title": "Meta.linebreak", "contents": "linebreak t string ", "rendered": "<h4 class='item'>let linebreak: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.delimiter", "title": "Meta.delimiter", "contents": "delimiter t string ", "rendered": "<h4 class='item'>let delimiter: <a href=\"./api/DojoComments.html#type-Meta.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Meta.t", "title": "Meta.t", "contents": "t string string bool array string bool t delimiter linebreak aborted fields truncated", "rendered": "<h4 class='item'>let t: (\n  ~delimiter: string,\n  ~linebreak: string,\n  ~aborted: bool,\n  ~fields: array(string),\n  ~truncated: bool\n) => <a href=\"./api/DojoComments.html#type-Meta.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#type-Meta.t", "title": "Meta.t", "contents": "t ", "rendered": "<h4 class='item'>type t</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Meta", "title": "Meta", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Meta", "title": "Meta", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Meta", "title": "Meta", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.row", "title": "Error.row", "contents": "row t int ", "rendered": "<h4 class='item'>let row: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => int</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.message", "title": "Error.message", "contents": "message t string ", "rendered": "<h4 class='item'>let message: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.code", "title": "Error.code", "contents": "code t string ", "rendered": "<h4 class='item'>let code: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.type_", "title": "Error.type_", "contents": "type_ t string ", "rendered": "<h4 class='item'>let type_: <a href=\"./api/DojoComments.html#type-Error.t\">t</a> => string</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#value-Error.t", "title": "Error.t", "contents": "t string string string int t type_ code message row", "rendered": "<h4 class='item'>let t: (\n  ~type_: string,\n  ~code: string,\n  ~message: string,\n  ~row: int\n) => <a href=\"./api/DojoComments.html#type-Error.t\">t</a></h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#type-Error.t", "title": "Error.t", "contents": "t ", "rendered": "<h4 class='item'>type t</h4>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Error", "title": "Error", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Error", "title": "Error", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#module-Error", "title": "Error", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html", "title": "DojoComments", "contents": "@rest", "rendered": "@rest", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html", "title": "DojoComments", "contents": "This module does not have a toplevel documentation block.", "rendered": "<span class='missing'>This module does not have a toplevel documentation block.</span>", "breadcrumb": "DojoComments"},
{"href": "./api/DojoComments.html#DojoComments", "title": "DojoComments", "contents": "", "rendered": "", "breadcrumb": "DojoComments"}]